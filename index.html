<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>AM Network</title>
  <meta name="description" content="AM Network — all my important links in one place." />

  <!-- Orbitron - Aggressive Gaming Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;800;900&family=Rajdhani:wght@500;600;700&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <!-- Background canvases -->
  <canvas id="bg"></canvas>
  <canvas id="sparks"></canvas>

  <!-- Thunder flash overlay -->
  <div class="thunder-flash" id="thunderFlash" aria-hidden="true"></div>

  <!-- Glitch overlay -->
  <div class="glitch-overlay" aria-hidden="true"></div>

  <div class="edge edge-top"></div>
  <div class="edge edge-bottom"></div>
  <div class="edge edge-left"></div>
  <div class="edge edge-right"></div>

  <main class="wrap">
    <header class="hero">

      <!-- Diamond sparkle canvas -->
      <canvas id="diamondSparks" aria-hidden="true"></canvas>

      <!-- Name sparks overlay -->
      <canvas id="nameSparks" aria-hidden="true"></canvas>

      <!-- Arc lightning canvas -->
      <canvas id="arcLightning" aria-hidden="true"></canvas>

      <!-- Thunder bolt canvas -->
      <canvas id="thunderBolt" aria-hidden="true"></canvas>

      <!-- NAME SVG - ULTRA WIDE viewBox for MAXIMUM size -->
      <svg id="nameSvg" viewBox="0 0 420 80" preserveAspectRatio="xMidYMid meet" aria-label="ANKIT MALIK" role="img">
        <defs>
          <!-- Enhanced Glow filter -->
          <filter id="glow" x="-100%" y="-120%" width="300%" height="360%">
            <feGaussianBlur stdDeviation="10" result="b"/>
            <feColorMatrix in="b" type="matrix"
              values="1 0 0 0 0
                      0 1 0 0 0
                      0 0 1 0 0
                      0 0 0 1.2 0"/>
            <feMerge>
              <feMergeNode/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>

          <!-- Chrome reflection filter -->
          <filter id="chrome" x="-20%" y="-20%" width="140%" height="140%">
            <feGaussianBlur in="SourceAlpha" stdDeviation="2" result="blur"/>
            <feSpecularLighting in="blur" surfaceScale="5" specularConstant="1" specularExponent="20" result="spec">
              <fePointLight x="200" y="-100" z="200"/>
            </feSpecularLighting>
            <feComposite in="spec" in2="SourceAlpha" operator="in" result="specOut"/>
            <feMerge>
              <feMergeNode in="SourceGraphic"/>
              <feMergeNode in="specOut"/>
            </feMerge>
          </filter>

          <!-- Glitch displacement -->
          <filter id="glitchFilter" x="-10%" y="-10%" width="120%" height="120%">
            <feTurbulence type="fractalNoise" baseFrequency="0.01" numOctaves="1" result="noise" seed="0">
              <animate attributeName="seed" values="0;100;0" dur="0.5s" repeatCount="indefinite"/>
            </feTurbulence>
            <feDisplacementMap in="SourceGraphic" in2="noise" scale="0" xChannelSelector="R" yChannelSelector="G">
              <animate attributeName="scale" values="0;6;0;0;0;10;0;0;0;0" dur="2.5s" repeatCount="indefinite"/>
            </feDisplacementMap>
          </filter>

          <!-- Main neon gradient -->
          <linearGradient id="strokeGrad" x1="0" x2="1" y1="0" y2="0">
            <stop offset="0%" stop-color="#46f7ff"/>
            <stop offset="35%" stop-color="#eaf6ff"/>
            <stop offset="65%" stop-color="#b84bff"/>
            <stop offset="100%" stop-color="#ff4b8b"/>
          </linearGradient>

          <!-- Chrome metallic gradient -->
          <linearGradient id="chromeGrad" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="#ffffff"/>
            <stop offset="25%" stop-color="#c0c0c0"/>
            <stop offset="50%" stop-color="#ffffff"/>
            <stop offset="75%" stop-color="#a0a0a0"/>
            <stop offset="100%" stop-color="#e0e0e0"/>
          </linearGradient>

          <!-- Metallic sheen wave -->
          <linearGradient id="waveGlow" x1="-1" x2="0" y1="0" y2="0">
            <stop offset="0%"   stop-color="rgba(255,255,255,0)"/>
            <stop offset="20%"  stop-color="rgba(255,255,255,0.15)"/>
            <stop offset="35%"  stop-color="rgba(234,246,255,0.9)"/>
            <stop offset="50%"  stop-color="rgba(255,255,255,1)"/>
            <stop offset="65%"  stop-color="rgba(70,247,255,0.85)"/>
            <stop offset="80%"  stop-color="rgba(184,75,255,0.3)"/>
            <stop offset="100%" stop-color="rgba(184,75,255,0)"/>
            <animate attributeName="x1" values="-1;1.5" dur="1.8s" repeatCount="indefinite"/>
            <animate attributeName="x2" values="0;2.5" dur="1.8s" repeatCount="indefinite"/>
          </linearGradient>

          <!-- RGB Split gradients -->
          <linearGradient id="redShift" x1="0" x2="1" y1="0" y2="0">
            <stop offset="0%" stop-color="#ff0040"/>
            <stop offset="100%" stop-color="#ff4b8b"/>
          </linearGradient>
          <linearGradient id="cyanShift" x1="0" x2="1" y1="0" y2="0">
            <stop offset="0%" stop-color="#00ffff"/>
            <stop offset="100%" stop-color="#46f7ff"/>
          </linearGradient>
        </defs>

        <!-- RGB Split layers (Glitch effect) -->
        <text x="50%" y="55%" class="name glitch-r">ANKIT MALIK</text>
        <text x="50%" y="55%" class="name glitch-c">ANKIT MALIK</text>

        <!-- Base chrome body -->
        <text x="50%" y="55%" class="name chrome-base">ANKIT MALIK</text>

        <!-- Main neon stroke -->
        <text x="50%" y="55%" class="name neon">ANKIT MALIK</text>

        <!-- Electric Edge Pulse -->
        <text x="50%" y="55%" class="name pulse">ANKIT MALIK</text>

        <!-- Chrome highlight -->
        <text x="50%" y="55%" class="name chrome-shine">ANKIT MALIK</text>

        <!-- Metallic sheen wave -->
        <text x="50%" y="55%" class="name wave">ANKIT MALIK</text>

        <!-- Glitch displacement layer -->
        <text x="50%" y="55%" class="name glitch-main">ANKIT MALIK</text>
      </svg>

      <div class="tagline">AM Network — A network built for my ideas.</div>
    </header>

    <!-- FEATURED -->
    <section class="card">
      <h3 class="sectionTitle">FEATURED</h3>
      <div class="list">
        <a class="btn featured" id="featuredBtn" href="#" target="_blank" rel="noopener">
          <span class="ico">★</span>
          <span class="txt">Loading…</span>
        </a>
      </div>
    </section>

    <!-- LINKS -->
    <section class="card">
      <h3 class="sectionTitle">LINKS</h3>
      <div class="list" id="linksList">
        <div class="skeleton">Loading links…</div>
      </div>
    </section>

    <div class="foot">© <span id="yr"></span> AM Network</div>
  </main>

  <script src="script.js"></script>

  <!-- DIAMOND SPARKLES -->
  <script>
    (() => {
      const c = document.getElementById("diamondSparks");
      if(!c) return;
      const ctx = c.getContext("2d", { alpha:true });

      let W=0, H=0, dpr=1;
      const sparkles = [];

      function resize(){
        const svg = document.getElementById("nameSvg");
        if(!svg) return;
        const r = svg.getBoundingClientRect();
        dpr = Math.min(2, window.devicePixelRatio || 1);
        W = Math.max(1, Math.floor(r.width));
        H = Math.max(1, Math.floor(Math.min(220, Math.max(180, r.height * 1.1))));
        c.style.width = W + "px";
        c.style.height = H + "px";
        c.width = Math.floor(W * dpr);
        c.height = Math.floor(H * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
      addEventListener("resize", resize, { passive:true });
      resize();

      const rand = (a,b) => a + Math.random()*(b-a);

      function spawnDiamond(){
        if(sparkles.length > 35) return;
        if(Math.random() > 0.12) return;
        
        sparkles.push({
          x: rand(W*0.05, W*0.95),
          y: rand(H*0.15, H*0.80),
          size: rand(2, 7),
          life: rand(18, 45),
          maxLife: rand(18, 45),
          rotation: rand(0, Math.PI),
          rotSpeed: rand(-0.12, 0.12),
          color: Math.random() > 0.5 ? '#ffffff' : (Math.random() > 0.5 ? '#46f7ff' : '#b84bff')
        });
      }

      function drawDiamond(x, y, size, rotation, alpha, color){
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.globalAlpha = alpha;
        
        ctx.beginPath();
        ctx.moveTo(0, -size);
        ctx.lineTo(size*0.3, 0);
        ctx.lineTo(0, size);
        ctx.lineTo(-size*0.3, 0);
        ctx.closePath();
        
        ctx.fillStyle = color;
        ctx.shadowBlur = 18;
        ctx.shadowColor = color;
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(-size, 0);
        ctx.lineTo(size, 0);
        ctx.moveTo(0, -size);
        ctx.lineTo(0, size);
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.shadowBlur = 22;
        ctx.stroke();
        
        ctx.restore();
      }

      function animate(){
        ctx.clearRect(0,0,W,H);
        spawnDiamond();

        for(let i=sparkles.length-1; i>=0; i--){
          const s = sparkles[i];
          s.life--;
          s.rotation += s.rotSpeed;
          
          const progress = s.life / s.maxLife;
          const alpha = progress < 0.3 ? progress/0.3 : (progress > 0.7 ? (1-progress)/0.3 : 1);
          
          drawDiamond(s.x, s.y, s.size * (0.5 + alpha*0.5), s.rotation, alpha * 0.9, s.color);
          
          if(s.life <= 0) sparkles.splice(i, 1);
        }

        requestAnimationFrame(animate);
      }
      animate();
    })();
  </script>

  <!-- LIGHTNING SPARKS -->
  <script>
    (() => {
      const c = document.getElementById("nameSparks");
      if(!c) return;
      const ctx = c.getContext("2d", { alpha:true });

      let W=0,H=0,dpr=1;

      function resize(){
        const svg = document.getElementById("nameSvg");
        if(!svg) return;
        const r = svg.getBoundingClientRect();
        dpr = Math.min(2, window.devicePixelRatio || 1);
        W = Math.max(1, Math.floor(r.width));
        H = Math.max(1, Math.floor(Math.min(220, Math.max(180, r.height * 1.1))));
        c.style.width = W + "px";
        c.style.height = H + "px";
        c.width = Math.floor(W * dpr);
        c.height = Math.floor(H * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
      addEventListener("resize", resize, { passive:true });
      resize();

      const sparks = [];
      const rand = (a,b)=> a + Math.random()*(b-a);

      function spawn(){
        for(let k=0;k<3;k++){
          if(sparks.length > 100) break;
          if(Math.random() > 0.70) continue;

          const x = rand(W*0.05, W*0.95);
          const y = rand(H*0.18, H*0.85);
          const len = rand(12, 30);
          const ang = rand(-0.9, 0.9);

          sparks.push({
            x,y, ang, len,
            vx: rand(-0.30,0.30),
            vy: rand(-0.12,0.12),
            life: rand(22, 40),
            a: rand(0.30, 0.80),
            branches: Math.floor(rand(1, 3))
          });
        }
      }

      function draw(){
        ctx.clearRect(0,0,W,H);

        for(let i=sparks.length-1;i>=0;i--){
          const s = sparks[i];
          s.x += s.vx;
          s.y += s.vy;
          s.life -= 1;

          const fade = Math.max(0, s.life/40);
          ctx.globalAlpha = s.a * fade;

          const x2 = s.x + Math.cos(s.ang) * s.len;
          const y2 = s.y + Math.sin(s.ang) * s.len;
          
          ctx.beginPath();
          ctx.moveTo(s.x, s.y);
          
          let px = s.x, py = s.y;
          const segments = 4;
          for(let j=1; j<=segments; j++){
            const t = j/segments;
            const nx = s.x + (x2-s.x)*t + rand(-6,6);
            const ny = s.y + (y2-s.y)*t + rand(-5,5);
            ctx.lineTo(nx, ny);
            px = nx; py = ny;
          }
          
          ctx.lineWidth = 1.8;
          ctx.strokeStyle = "rgba(255,255,255,1)";
          ctx.shadowBlur = 16;
          ctx.shadowColor = Math.random() > 0.5 ? "rgba(70,247,255,.9)" : "rgba(184,75,255,.9)";
          ctx.stroke();

          for(let b=0; b<s.branches; b++){
            const bt = rand(0.3, 0.7);
            const bx = s.x + (x2-s.x)*bt;
            const by = s.y + (y2-s.y)*bt;
            const bang = s.ang + rand(-1.2, 1.2);
            const blen = s.len * rand(0.3, 0.5);
            
            ctx.beginPath();
            ctx.moveTo(bx, by);
            ctx.lineTo(bx + Math.cos(bang)*blen + rand(-3,3), by + Math.sin(bang)*blen + rand(-3,3));
            ctx.lineWidth = 1;
            ctx.stroke();
          }

          ctx.beginPath();
          ctx.arc(s.x, s.y, 2, 0, Math.PI*2);
          ctx.fillStyle = "rgba(255,255,255,1)";
          ctx.shadowBlur = 12;
          ctx.fill();

          if(s.life <= 0) sparks.splice(i,1);
        }

        ctx.globalAlpha = 1;
        requestAnimationFrame(draw);
      }

      function loop(){
        spawn();
        setTimeout(loop, 60);
      }

      loop();
      draw();
    })();
  </script>

  <!-- ARC LIGHTNING -->
  <script>
    (() => {
      const c = document.getElementById("arcLightning");
      if(!c) return;
      const ctx = c.getContext("2d", { alpha:true });

      let W=0, H=0, dpr=1;
      const arcs = [];

      function resize(){
        const svg = document.getElementById("nameSvg");
        if(!svg) return;
        const r = svg.getBoundingClientRect();
        dpr = Math.min(2, window.devicePixelRatio || 1);
        W = Math.max(1, Math.floor(r.width));
        H = Math.max(1, Math.floor(Math.min(220, Math.max(180, r.height * 1.1))));
        c.style.width = W + "px";
        c.style.height = H + "px";
        c.width = Math.floor(W * dpr);
        c.height = Math.floor(H * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
      addEventListener("resize", resize, { passive:true });
      resize();

      const rand = (a,b) => a + Math.random()*(b-a);

      function spawnArc(){
        if(arcs.length > 6) return;
        if(Math.random() > 0.025) return;
        
        const x1 = rand(W*0.12, W*0.42);
        const x2 = rand(W*0.58, W*0.88);
        const y = rand(H*0.30, H*0.70);
        
        arcs.push({
          x1, x2,
          y1: y + rand(-12, 12),
          y2: y + rand(-12, 12),
          life: rand(6, 14),
          intensity: rand(0.5, 1)
        });
      }

      function drawArc(arc){
        const fade = arc.life / 14;
        ctx.globalAlpha = arc.intensity * fade;
        
        ctx.beginPath();
        ctx.moveTo(arc.x1, arc.y1);
        
        const segments = 6;
        for(let i=1; i<=segments; i++){
          const t = i/segments;
          const x = arc.x1 + (arc.x2 - arc.x1) * t;
          const y = arc.y1 + (arc.y2 - arc.y1) * t + rand(-10, 10);
          ctx.lineTo(x, y);
        }
        
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = rand(1.2, 2.5);
        ctx.shadowBlur = 22;
        ctx.shadowColor = Math.random() > 0.5 ? '#46f7ff' : '#b84bff';
        ctx.stroke();
        
        ctx.strokeStyle = ctx.shadowColor;
        ctx.lineWidth = 0.8;
        ctx.shadowBlur = 30;
        ctx.stroke();
      }

      function animate(){
        ctx.clearRect(0,0,W,H);
        spawnArc();

        for(let i=arcs.length-1; i>=0; i--){
          drawArc(arcs[i]);
          arcs[i].life--;
          if(arcs[i].life <= 0) arcs.splice(i, 1);
        }

        ctx.globalAlpha = 1;
        requestAnimationFrame(animate);
      }
      animate();
    })();
  </script>

  <!-- NATURAL THUNDER EFFECT - Rare but intense -->
  <script>
    (() => {
      const flash = document.getElementById("thunderFlash");
      const boltCanvas = document.getElementById("thunderBolt");
      if(!flash || !boltCanvas) return;
      
      const ctx = boltCanvas.getContext("2d", { alpha: true });
      let W = 0, H = 0, dpr = 1;

      function resize(){
        const svg = document.getElementById("nameSvg");
        if(!svg) return;
        const r = svg.getBoundingClientRect();
        dpr = Math.min(2, window.devicePixelRatio || 1);
        W = Math.max(1, Math.floor(r.width));
        H = Math.max(1, Math.floor(Math.min(250, Math.max(200, r.height * 1.2))));
        boltCanvas.style.width = W + "px";
        boltCanvas.style.height = H + "px";
        boltCanvas.width = Math.floor(W * dpr);
        boltCanvas.height = Math.floor(H * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
      addEventListener("resize", resize, { passive: true });
      resize();

      const rand = (a, b) => a + Math.random() * (b - a);

      function drawThunderBolt(startX, startY, endX, endY, width, branches){
        ctx.beginPath();
        ctx.moveTo(startX, startY);

        let x = startX, y = startY;
        const dx = endX - startX;
        const dy = endY - startY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const segments = Math.floor(dist / 15);
        
        const points = [{x, y}];

        for(let i = 1; i <= segments; i++){
          const t = i / segments;
          const nx = startX + dx * t + rand(-25, 25);
          const ny = startY + dy * t + rand(-8, 8);
          ctx.lineTo(nx, ny);
          points.push({x: nx, y: ny});
          x = nx; y = ny;
        }

        ctx.strokeStyle = "rgba(255,255,255,1)";
        ctx.lineWidth = width;
        ctx.shadowBlur = 35;
        ctx.shadowColor = "rgba(70,247,255,1)";
        ctx.stroke();

        // Outer glow
        ctx.strokeStyle = "rgba(70,247,255,0.6)";
        ctx.lineWidth = width + 4;
        ctx.shadowBlur = 50;
        ctx.stroke();

        // Draw branches
        if(branches > 0){
          for(let i = 0; i < branches; i++){
            const pIdx = Math.floor(rand(1, points.length - 1));
            const p = points[pIdx];
            const bEndX = p.x + rand(-80, 80);
            const bEndY = p.y + rand(20, 60);
            
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            
            const bSegs = 3;
            for(let j = 1; j <= bSegs; j++){
              const bt = j / bSegs;
              ctx.lineTo(
                p.x + (bEndX - p.x) * bt + rand(-15, 15),
                p.y + (bEndY - p.y) * bt + rand(-5, 5)
              );
            }
            
            ctx.strokeStyle = "rgba(255,255,255,0.8)";
            ctx.lineWidth = width * 0.5;
            ctx.shadowBlur = 25;
            ctx.shadowColor = "rgba(184,75,255,0.8)";
            ctx.stroke();
          }
        }
      }

      function triggerThunder(){
        // Clear canvas
        ctx.clearRect(0, 0, W, H);
        
        // Flash sequence: quick double flash like real lightning
        flash.classList.add("active");
        
        // Draw main bolt
        const startX = rand(W * 0.2, W * 0.8);
        const startY = 0;
        const endX = startX + rand(-50, 50);
        const endY = H * 0.9;
        
        drawThunderBolt(startX, startY, endX, endY, rand(2.5, 4), Math.floor(rand(2, 5)));
        
        // First flash off
        setTimeout(() => {
          flash.classList.remove("active");
        }, 80);
        
        // Second flash (aftershock)
        setTimeout(() => {
          flash.classList.add("active");
          // Redraw slightly different bolt
          ctx.clearRect(0, 0, W, H);
          drawThunderBolt(startX + rand(-20, 20), startY, endX + rand(-30, 30), endY, rand(2, 3.5), Math.floor(rand(1, 4)));
        }, 150);
        
        // Final fade
        setTimeout(() => {
          flash.classList.remove("active");
        }, 220);
        
        // Clear bolt
        setTimeout(() => {
          ctx.clearRect(0, 0, W, H);
        }, 400);
      }

      // Random thunder - rare occurrence (every 4-12 seconds)
      function scheduleThunder(){
        const delay = rand(4000, 12000);
        setTimeout(() => {
          if(Math.random() > 0.3){ // 70% chance when scheduled
            triggerThunder();
          }
          scheduleThunder();
        }, delay);
      }

      // Start thunder cycle after initial delay
      setTimeout(scheduleThunder, rand(2000, 5000));
    })();
  </script>

  <!-- GLITCH EFFECT -->
  <script>
    (() => {
      const overlay = document.querySelector('.glitch-overlay');
      if(!overlay) return;

      function triggerGlitch(){
        if(Math.random() > 0.88){
          overlay.classList.add('active');
          setTimeout(() => overlay.classList.remove('active'), rand(40, 150));
        }
        setTimeout(triggerGlitch, rand(600, 2500));
      }

      function rand(a,b){ return a + Math.random()*(b-a); }
      triggerGlitch();
    })();
  </script>
</body>
</html>
